{"sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/GettingStarted"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/parsing\/gettingstarted"]}],"seeAlsoSections":[{"generated":true,"identifiers":["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Design","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/StringAbstractions","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ErrorMessages","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Backtracking"],"title":"Articles"}],"schemaVersion":{"major":0,"minor":3,"patch":0},"primaryContentSections":[{"kind":"content","content":[{"text":"Adding Parsing as a dependency","anchor":"Adding-Parsing-as-a-dependency","level":2,"type":"heading"},{"inlineContent":[{"text":"To use the Parsing library in a SwiftPM project, add it to the dependencies of your Package.swift","type":"text"},{"text":" ","type":"text"},{"text":"and specify the ","type":"text"},{"code":"Parsing","type":"codeVoice"},{"text":" product in any targets that need access to the library:","type":"text"}],"type":"paragraph"},{"code":["let package = Package(","  dependencies: [","    .package(url: \"https:\/\/github.com\/pointfreeco\/swift-parsing\", from: \"0.7.0\"),","  ],","  targets: [","    .target(","      name: \"<target-name>\",","      dependencies: [.product(name: \"Parsing\", package: \"swift-parsing\")]","    )","  ]",")"],"syntax":"swift","type":"codeListing"},{"text":"Your first parser","anchor":"Your-first-parser","level":2,"type":"heading"},{"inlineContent":[{"text":"Suppose you have a string that holds some user data that you want to parse into an array of ","type":"text"},{"type":"codeVoice","code":"User"},{"text":"s:","type":"text"}],"type":"paragraph"},{"code":["let input = \"\"\"","  1,Blob,true","  2,Blob Jr.,false","  3,Blob Sr.,true","  \"\"\"","","struct User {","  var id: Int","  var name: String","  var isAdmin: Bool","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"A naive approach to this would be a nested use of ","type":"text"},{"code":".split(separator:)","type":"codeVoice"},{"text":", and then a little bit of","type":"text"},{"text":" ","type":"text"},{"text":"extra work to convert strings into integers and booleans:","type":"text"}],"type":"paragraph"},{"code":["let users = input","  .split(separator: \"\\n\")","  .compactMap { row -> User? in","    let fields = row.split(separator: \",\")","    guard","      fields.count == 3,","      let id = Int(fields[0]),","      let isAdmin = Bool(String(fields[2]))","    else { return nil }","","    return User(id: id, name: String(fields[1]), isAdmin: isAdmin)","  }"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Not only is this code a little messy, but it is also inefficient since we are allocating arrays for","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"code":".split","type":"codeVoice"},{"text":" and then just immediately throwing away those values.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"It would be more straightforward and efficient to instead describe how to consume bits from the"},{"type":"text","text":" "},{"type":"text","text":"beginning of the input and convert that into users. This is what this parser library excels at 😄."}],"type":"paragraph"},{"inlineContent":[{"text":"We can start by describing what it means to parse a single row, first by parsing an integer off the","type":"text"},{"text":" ","type":"text"},{"text":"front of the string, and then parsing a comma. We can do this by using the ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parse","isActive":true,"type":"reference"},{"text":" type, which acts","type":"text"},{"text":" ","type":"text"},{"text":"as an entry point into describing a list of parsers that you want to run one after the other to","type":"text"},{"text":" ","type":"text"},{"text":"consume from an input:","type":"text"}],"type":"paragraph"},{"code":["let user = Parse {","  Int.parser()","  \",\"","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Already this can consume the leading integer and comma from the beginning of the input:"}],"type":"paragraph"},{"code":["\/\/ Use a mutable substring to verify what is consumed","var input = input[...]","","try user.parse(&input)  \/\/ ✅ 1","input \/\/ \"Blob,true\\n2,Blob Jr.,false\\n3,Blob Sr.,true\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Next we want to take everything up until the next comma for the user’s name, and then consume the"},{"type":"text","text":" "},{"type":"text","text":"comma:"}],"type":"paragraph"},{"code":["let user = Parse {","  Int.parser()","  \",\"","  Prefix { $0 != \",\" }","  \",\"","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"And then we want to take the boolean at the end of the row for the user’s admin status:"}],"type":"paragraph"},{"code":["let user = Parse {","  Int.parser()","  \",\"","  Prefix { $0 != \",\" }","  \",\"","  Bool.parser()","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Currently this will parse a tuple "},{"type":"codeVoice","code":"(Int, Substring, Bool)"},{"type":"text","text":" from the input, and we can "},{"type":"codeVoice","code":".map"},{"type":"text","text":" on"},{"type":"text","text":" "},{"type":"text","text":"that to turn it into a "},{"type":"codeVoice","code":"User"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["let user = Parse {","  Int.parser()","  \",\"","  Prefix { $0 != \",\" }","  \",\"","  Bool.parser()","}",".map { User(id: $0, name: String($1), isAdmin: $2) }"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"To make the data we are parsing to more prominent, we can instead pass the transform closure as the"},{"type":"text","text":" "},{"type":"text","text":"first argument to "},{"type":"codeVoice","code":"Parse"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["let user = Parse {","  User(id: $0, name: String($1), isAdmin: $2)","} with: {","  Int.parser()","  \",\"","  Prefix { $0 != \",\" }","  \",\"","  Bool.parser()","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Or we can pass the ","type":"text"},{"code":"User","type":"codeVoice"},{"text":" initializer to ","type":"text"},{"code":"Parse","type":"codeVoice"},{"text":" in a point-free style by first transforming the","type":"text"},{"text":" ","type":"text"},{"code":"Prefix","type":"codeVoice"},{"text":" parser’s output from a ","type":"text"},{"code":"Substring","type":"codeVoice"},{"text":" to a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"code":["let user = Parse(User.init(id:name:isAdmin:)) {","  Int.parser()","  \",\"","  Prefix { $0 != \",\" }.map(String.init)","  \",\"","  Bool.parser()","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"That is enough to parse a single user from the input string, leaving behind a newline and the final"},{"type":"text","text":" "},{"type":"text","text":"two users:"}],"type":"paragraph"},{"code":["try user.parse(&input)","\/\/ ✅ User(id: 1, name: \"Blob\", isAdmin: true)","input \/\/ \"\\n2,Blob Jr.,false\\n3,Blob Sr.,true\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"To parse multiple users from the input we can use the "},{"type":"codeVoice","code":"Many"},{"type":"text","text":" parser to run the user parser many"},{"type":"text","text":" "},{"type":"text","text":"times:"}],"type":"paragraph"},{"code":["let users = Many {","  user","} separator: {","  \"\\n\"","}","","try users.parse(&input)","\/\/ ✅ [User(id: 1, name: \"Blob\", isAdmin: true), ...]","input \/\/ \"\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Now this parser can process an entire document of users, and the code is simpler and more","type":"text"},{"text":" ","type":"text"},{"text":"straightforward than the version that uses ","type":"text"},{"code":".split","type":"codeVoice"},{"text":" and ","type":"text"},{"code":".compactMap","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Even better, it’s more performant. We’ve written "},{"identifier":"https:\/\/github.com\/pointfreeco\/swift-parsing\/blob\/main\/Sources\/swift-parsing-benchmark\/ReadmeExample.swift","type":"reference","isActive":true},{"type":"text","text":" for these two"},{"type":"text","text":" "},{"type":"text","text":"styles of parsing, and the "},{"code":".split","type":"codeVoice"},{"type":"text","text":"-style of parsing is more than twice as slow:"}],"type":"paragraph"},{"code":["name                             time        std        iterations","------------------------------------------------------------------","README Example.Parser: Substring 3426.000 ns ±  63.40 %     385395","README Example.Ad hoc            7631.000 ns ±  47.01 %     169332"],"syntax":null,"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Further, if you are willing write your parsers against "},{"type":"codeVoice","code":"UTF8View"},{"type":"text","text":" instead of "},{"type":"codeVoice","code":"Substring"},{"type":"text","text":", you can"},{"type":"text","text":" "},{"type":"text","text":"eke out even more performance, more than doubling the speed:"}],"type":"paragraph"},{"code":["name                             time        std        iterations","------------------------------------------------------------------","README Example.Parser: Substring 3693.000 ns ±  81.76 %     349763","README Example.Parser: UTF8      1272.000 ns ± 128.16 %     999150","README Example.Ad hoc            8504.000 ns ±  59.59 %     151417"],"syntax":null,"type":"codeListing"},{"inlineContent":[{"text":"See the article ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/StringAbstractions","type":"reference","isActive":true},{"text":" for more info on how to write parsers against different","type":"text"},{"text":" ","type":"text"},{"text":"string abstraction levels.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We can also compare these times to a tool that Apple’s Foundation gives us: "},{"type":"codeVoice","code":"Scanner"},{"type":"text","text":". It’s a type"},{"type":"text","text":" "},{"type":"text","text":"that allows you to consume from the beginning of strings in order to produce values, and provides"},{"type":"text","text":" "},{"type":"text","text":"a nicer API than using "},{"type":"codeVoice","code":".split"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["var users: [User] = []","while scanner.currentIndex != input.endIndex {","  guard","    let id = scanner.scanInt(),","    let _ = scanner.scanString(\",\"),","    let name = scanner.scanUpToString(\",\"),","    let _ = scanner.scanString(\",\"),","    let isAdmin = scanner.scanBool()","  else { break }","","  users.append(User(id: id, name: name, isAdmin: isAdmin))","  _ = scanner.scanString(\"\\n\")","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"However, the "},{"code":"Scanner","type":"codeVoice"},{"type":"text","text":" style of parsing is more than 5 times as slow as the substring parser written"},{"type":"text","text":" "},{"type":"text","text":"written above, and more than 15 times slower than the UTF-8 parser:"}],"type":"paragraph"},{"code":["name                             time         std        iterations","-------------------------------------------------------------------","README Example.Parser: Substring  3481.000 ns ±  65.04 %     376525","README Example.Parser: UTF8       1207.000 ns ± 110.96 %    1000000","README Example.Ad hoc             8029.000 ns ±  44.44 %     163719","README Example.Scanner           19786.000 ns ±  35.26 %      62125"],"syntax":null,"type":"codeListing"},{"inlineContent":[{"text":"Not only are parsers built with the library more succinct and many times more performant than ad hoc","type":"text"},{"text":" ","type":"text"},{"text":"parsers, but they can also be easier to evolve to accommodate more features. For example, right now","type":"text"},{"text":" ","type":"text"},{"text":"our parser does not work correctly when the user’s name contains a comma, such as “Blob, Esq.”:","type":"text"}],"type":"paragraph"},{"code":["try user.parse(\"1,Blob, Esq.,true\")","","\/\/ error: unexpected input","\/\/  --> input:1:8","\/\/ 1 | 1,Blob, Esq.,true","\/\/   |        ^ expected \"true\" or \"false\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The problem is that we are using the comma as a reserved identifier for delineating between fields,","type":"text"},{"text":" ","type":"text"},{"text":"and so a field cannot contain a comma. We can enhance the CSV format to allow for quoting fields","type":"text"},{"text":" ","type":"text"},{"text":"so that they can contain quotes:","type":"text"}],"type":"paragraph"},{"code":["1,\"Blob, Esq.\",true"],"syntax":null,"type":"codeListing"},{"inlineContent":[{"type":"text","text":"To parse quoted fields we can first try parsing a quote, then everything up to the next quote, and"},{"type":"text","text":" "},{"type":"text","text":"then the trailing quote:"}],"type":"paragraph"},{"code":["let quotedField = Parse {","  \"\\\"\"","  Prefix { $0 != \"\\\"\" }","  \"\\\"\"","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"And then to parse a field, in general, we can first try parsing a quoted field, and if that fails we"},{"type":"text","text":" "},{"type":"text","text":"will just take everything until the next comma. We can do this using the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf"},{"type":"text","text":" parser, which"},{"type":"text","text":" "},{"type":"text","text":"allows us to run multiple parsers on the same input, and it will take the first that succeeds:"}],"type":"paragraph"},{"code":["let field = OneOf {","  quotedField","  Prefix { $0 != \",\" }","}",".map(String.init)"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"We can use this parser in the "},{"type":"codeVoice","code":"user"},{"type":"text","text":" parser, and now it properly handles quoted and non-quoted"},{"type":"text","text":" "},{"type":"text","text":"fields:"}],"type":"paragraph"},{"code":["let user = Parse(User.init) {","  Int.parser()","  \",\"","  field","  \",\"","  Bool.parser()","}","","try user.parse(\"1,\\\"Blob, Esq.\\\",true\")","\/\/ ✅ User(id: 1, name: \"Blob, Esq.\", isAdmin: true)"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"It was quite straightforward to improve the "},{"type":"codeVoice","code":"user"},{"type":"text","text":" parser to handle quoted fields. Doing the same"},{"type":"text","text":" "},{"type":"text","text":"with our ad hoc "},{"type":"codeVoice","code":"split"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"compactMap"},{"type":"text","text":" parser, and even the "},{"type":"codeVoice","code":"Scanner"},{"type":"text","text":"-based parser, would be a lot"},{"type":"text","text":" "},{"type":"text","text":"more difficult."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"That’s the basics of parsing a simple string format, but there’s a lot more operators and tricks to"},{"type":"text","text":" "},{"type":"text","text":"learn in order to performantly parse larger inputs. View the "},{"type":"reference","identifier":"https:\/\/github.com\/pointfreeco\/swift-parsing\/tree\/main\/Sources\/swift-parsing-benchmark","isActive":true},{"type":"text","text":" for examples"},{"type":"text","text":" "},{"type":"text","text":"of real-life parsing scenarios."}],"type":"paragraph"},{"text":"Your first parser-printer","anchor":"Your-first-parser-printer","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"Once you build a parser to turn nebulous data into well-structured data, you may ask if the inverse"},{"type":"text","text":" "},{"type":"text","text":"process can also be performed. What if you need to turn your well-structured data back into nebulous"},{"type":"text","text":" "},{"type":"text","text":"data, such as if you needed to save the data back to disk or send the data to a server over the"},{"type":"text","text":" "},{"type":"text","text":"network. This inverse process is known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"printing"}]},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"If you are careful in the manner you construct your parser, there is a good chance that with a","type":"text"},{"text":" ","type":"text"},{"text":"little bit of extra work you can turn your parser into a printer. Most of the ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser","isActive":true,"type":"reference"},{"text":" ","type":"text"},{"text":"conformances that ship with the library also conform to the ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ParserPrinter","isActive":true,"type":"reference"},{"text":" protocol, although","type":"text"},{"text":" ","type":"text"},{"text":"many have additional constraints that need to be satisfied.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"As long as you stay within those constraints, or use operations that are printer-friendly, then your"},{"type":"text","text":" "},{"type":"text","text":"parser most likely is already a printer."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, the tiny parser we defined for parsing a quoted field:"}],"type":"paragraph"},{"code":["let quotedField = Parse {","  \"\\\"\"","  Prefix { $0 != \"\\\"\" }","  \"\\\"\"","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"This is already a printer because all of the parsers involved are also printers, such as the string"},{"type":"text","text":" "},{"type":"text","text":"parser "},{"type":"codeVoice","code":"\"\\\"\""},{"type":"text","text":" and the "},{"type":"codeVoice","code":"Prefix"},{"type":"text","text":" parser. Even the entry point "},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parse","type":"reference","isActive":true},{"type":"text","text":" is a printer when everything"},{"type":"text","text":" "},{"type":"text","text":"in the builder context is a printer. We also provide a special "},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ParsePrint","type":"reference","isActive":true},{"type":"text","text":" entry point to make"},{"type":"text","text":" "},{"type":"text","text":"this clearer."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"So we can call "},{"type":"reference","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ParserPrinter\/print(_:)","isActive":true},{"type":"text","text":" on this value, pass it a string, and it will give us back"},{"type":"text","text":" "},{"type":"text","text":"a quoted field:"}],"type":"paragraph"},{"code":["quotedField.print(\"Blob, Esq.\")  \/\/ ✅ \"\\\"Blob, Esq.\\\"\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"However, the ","type":"text"},{"code":"field","type":"codeVoice"},{"text":" parser, which first tries to parse a quoted field, and if that fails it falls","type":"text"},{"text":" ","type":"text"},{"text":"back to consuming everything until the next comma, is ","type":"text"},{"inlineContent":[{"type":"text","text":"not"}],"type":"emphasis"},{"text":" a printer currently:","type":"text"}],"type":"paragraph"},{"code":["let field = OneOf {","  quotedField","  Prefix { $0 != \",\" }","}",".map(String.init)","","try field.print(\"Blob, Esq.\")","\/\/ ❌ Value of type 'Parsers.Map<OneOf<...>, String>' has no member 'print'"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The problem here is that the ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser\/map(_:)-4hsj5","isActive":true,"type":"reference"},{"text":" operation is not printer-friendly. It can","type":"text"},{"text":" ","type":"text"},{"text":"describe how to transform a parser’s output into a new kind of output, such as ","type":"text"},{"code":"Substring","type":"codeVoice"},{"text":" into","type":"text"},{"text":" ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" like the above. But for printing we need the opposite direction. We need to be able to","type":"text"},{"text":" ","type":"text"},{"text":"transform ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" back into ","type":"text"},{"code":"Substring","type":"codeVoice"},{"text":" so that it can be plugged into the printer.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"To fix this we cannot use ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser\/map(_:)-4hsj5","isActive":true,"type":"reference"},{"text":" that simply uses one-directional transformations","type":"text"},{"text":" ","type":"text"},{"text":"for turning a parser’s output into a new output. We must use the more powerful","type":"text"},{"text":" ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser\/map(_:)-18m9d","isActive":true,"type":"reference"},{"text":" overload that takes a ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Conversion","isActive":true,"type":"reference"},{"text":", which is a type that describes a","type":"text"},{"text":" ","type":"text"},{"text":"process for converting from one type to another and back.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"If you map a parser-printer with a conversion, rather than just a simple function, you can transform","type":"text"},{"text":" ","type":"text"},{"text":"a parser-printer to another parser-printer. This library ships with many conversions (see","type":"text"},{"text":" ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Conversions","type":"reference","isActive":true},{"text":") that makes it easy to quickly transform outputs. For example, the ","type":"text"},{"type":"codeVoice","code":"field"},{"text":" ","type":"text"},{"text":"parser can be transformed with the ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Conversion\/string-swift.type.property-3u2b5","type":"reference","isActive":true},{"text":" conversion like","type":"text"},{"text":" ","type":"text"},{"text":"so:","type":"text"}],"type":"paragraph"},{"code":["let field = OneOf {","  quotedField","  Prefix { $0 != \",\" }","}",".map(.string)","","try field.parse(\"Blob\")            \/\/ ✅ \"Blob\"","try field.parse(\"\\\"Blob, Esq.\\\"\")  \/\/ ✅ \"Blob, Esq.\"","","try field.print(\"Blob\")            \/\/ ✅ \"Blob\"","try field.print(\"Blob, Esq.\")      \/\/ ✅ \"\\\"Blob, Esq.\\\"\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Although the "},{"code":"field","type":"codeVoice"},{"type":"text","text":" parser is now a parser-printer, the same is not true of the "},{"code":"user","type":"codeVoice"},{"type":"text","text":" parser:"}],"type":"paragraph"},{"code":["let user = Parse(User.init) {","  Int.parser()","  \",\"","  field","  \",\"","  Bool.parser()","}","","try user.parse(\"1,\\\"Blob, Esq.\\\",true\")","\/\/ ✅ User(id: 1, name: \"Blob, Esq.\", isAdmin: true)","","try user.print(User(id: 1, name: \"Blob\", isAdmin: true)) \/\/ ❌"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"It cannot print because secretly the "},{"type":"codeVoice","code":"Parse"},{"type":"text","text":" initializer that takes a transformation function,"},{"type":"text","text":" "},{"type":"text","text":"such as "},{"type":"codeVoice","code":"User.init"},{"type":"text","text":", uses a one-direction "},{"isActive":true,"type":"reference","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser\/map(_:)-4hsj5"},{"type":"text","text":" operation under the hood."},{"type":"text","text":" "},{"type":"text","text":"In order to make this a parser-printer we need to use "},{"isActive":true,"type":"reference","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Conversion\/memberwise(_:)"},{"type":"text","text":" which can"},{"type":"text","text":" "},{"type":"text","text":"derive a conversion between a tuple of data and a struct by specify the structs memberwise"},{"type":"text","text":" "},{"type":"text","text":"initializer:"}],"type":"paragraph"},{"code":["let user = ParsePrint(.memberwise(User.init)) {","  Int.parser()","  \",\"","  field","  \",\"","  Bool.parser()","}","","try user.parse(\"1,\\\"Blob, Esq.\\\",true\")","\/\/ ✅ User(id: 1, name: \"Blob, Esq.\", isAdmin: true)","","try user.print(User(id: 1, name: \"Blob, Esq.\", isAdmin: true))","\/\/ ✅ \"1,\"Blob, Esq.\",true\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"It was quite straightforward to turn the user parser into a user parser-printer. We simply needed","type":"text"},{"text":" ","type":"text"},{"text":"change all instances of a one-directional ","type":"text"},{"isActive":true,"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser\/map(_:)-4hsj5","type":"reference"},{"text":" to a bidirectional","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser\/map(_:)-18m9d","type":"reference"},{"text":", which uses a conversion for describing how to transform an output to","type":"text"},{"text":" ","type":"text"},{"text":"a new output and back.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"That’s the basics of parser-printers, but there’s a lot more operators and tricks to","type":"text"},{"text":" ","type":"text"},{"text":"learn in order to handle more complex domains. View the ","type":"text"},{"isActive":true,"overridingTitleInlineContent":[{"text":"benchmarks","type":"text"}],"type":"reference","identifier":"https:\/\/github.com\/pointfreeco\/swift-parsing\/tree\/main\/Sources\/swift-parsing-benchmark","overridingTitle":"benchmarks"},{"text":" for examples","type":"text"},{"text":" ","type":"text"},{"text":"of real-life parser-printer scenarios.","type":"text"}],"type":"paragraph"}]}],"kind":"article","metadata":{"roleHeading":"Article","role":"article","title":"Getting Started","modules":[{"name":"Parsing"}]},"abstract":[{"type":"text","text":"Learn how to integrate Parsing into your project and write your first parser."}],"hierarchy":{"paths":[["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing"],["doc:\/\/co.pointfree.Parsing\/documentation\/Parsing","doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser"]]},"references":{"doc://co.pointfree.Parsing/documentation/Parsing/ParserPrinter":{"navigatorTitle":[{"text":"ParserPrinter","kind":"identifier"}],"type":"topic","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ParserPrinter","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ParserPrinter","abstract":[{"text":"A ","type":"text"},{"type":"reference","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser","isActive":true},{"text":" that can incrementally “print” an output value back into an input.","type":"text"}],"url":"\/documentation\/parsing\/parserprinter","title":"ParserPrinter","role":"symbol","kind":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/Conversions":{"url":"\/documentation\/parsing\/conversions","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"A namespace for types that serve as conversions."}],"title":"Conversions","navigatorTitle":[{"kind":"identifier","text":"Conversions"}],"role":"symbol","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Conversions","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"Conversions"}]},"doc://co.pointfree.Parsing/documentation/Parsing/ParserBuilder":{"kind":"symbol","title":"ParserBuilder","abstract":[{"type":"text","text":"A custom parameter attribute that constructs parsers from closures. The constructed parser"},{"type":"text","text":" "},{"type":"text","text":"runs a number of parsers, one after the other, and accumulates their outputs."}],"navigatorTitle":[{"text":"ParserBuilder","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ParserBuilder","type":"topic","url":"\/documentation\/parsing\/parserbuilder","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ParserBuilder","kind":"identifier"}],"role":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/Conversion/memberwise(_:)":{"abstract":[{"text":"A conversion from a tuple of values into a struct and a struct into a tuple of values, using a","type":"text"},{"text":" ","type":"text"},{"text":"memberwise initializer.","type":"text"}],"title":"memberwise(_:)","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"memberwise","kind":"identifier"},{"text":"<","kind":"text"},{"text":"Values","kind":"genericParameter"},{"text":", ","kind":"text"},{"text":"Struct","kind":"genericParameter"},{"kind":"text","text":">(("},{"kind":"typeIdentifier","text":"Values"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Struct"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Self"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Conversion\/memberwise(_:)","type":"topic","url":"\/documentation\/parsing\/conversion\/memberwise(_:)","kind":"symbol","role":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/OneOf":{"type":"topic","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OneOf","kind":"identifier"}],"role":"symbol","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/OneOf","title":"OneOf","navigatorTitle":[{"text":"OneOf","kind":"identifier"}],"url":"\/documentation\/parsing\/oneof","abstract":[{"type":"text","text":"A parser that attempts to run a number of parsers till one succeeds."}]},"doc://co.pointfree.Parsing/documentation/Parsing/ErrorMessages":{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ErrorMessages","url":"\/documentation\/parsing\/errormessages","role":"article","title":"Error Messages","type":"topic","kind":"article","abstract":[{"type":"text","text":"Learn how the library reports parsing errors and how to integrate your own custom error messages"},{"type":"text","text":" "},{"type":"text","text":"into parsers."}]},"doc://co.pointfree.Parsing/documentation/Parsing/Backtracking":{"abstract":[{"text":"Learn what backtracking is, how it affects the performance of your parsers, and how to avoid it when","type":"text"},{"text":" ","type":"text"},{"text":"unnecessary.","type":"text"}],"kind":"article","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Backtracking","url":"\/documentation\/parsing\/backtracking","role":"article","type":"topic","title":"Backtracking"},"https://github.com/pointfreeco/swift-parsing/tree/main/Sources/swift-parsing-benchmark":{"identifier":"https:\/\/github.com\/pointfreeco\/swift-parsing\/tree\/main\/Sources\/swift-parsing-benchmark","titleInlineContent":[{"type":"text","text":"benchmarks"}],"url":"https:\/\/github.com\/pointfreeco\/swift-parsing\/tree\/main\/Sources\/swift-parsing-benchmark","title":"benchmarks","type":"link"},"doc://co.pointfree.Parsing/documentation/Parsing/Conversion/string-swift.type.property-3u2b5":{"conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"Self","type":"codeVoice"},{"text":" is ","type":"text"},{"code":"Conversions.SubstringToString","type":"codeVoice"},{"text":".","type":"text"}],"availabilityPrefix":[{"text":"Available when","type":"text"}]},"fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"string","kind":"identifier"},{"text":": ","kind":"text"},{"text":"Conversions","kind":"typeIdentifier","preciseIdentifier":"s:7Parsing11ConversionsO"},{"text":".","kind":"text"},{"text":"SubstringToString","preciseIdentifier":"s:7Parsing11ConversionsO17SubstringToStringV","kind":"typeIdentifier"}],"title":"string","type":"topic","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Conversion\/string-swift.type.property-3u2b5","abstract":[{"type":"text","text":"A conversion from "},{"code":"Substring","type":"codeVoice"},{"type":"text","text":" to "},{"type":"codeVoice","code":"String"},{"type":"text","text":"."}],"kind":"symbol","role":"symbol","url":"\/documentation\/parsing\/conversion\/string-swift.type.property-3u2b5"},"doc://co.pointfree.Parsing/documentation/Parsing/ParserPrinter/print(_:)":{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ParserPrinter\/print(_:)","url":"\/documentation\/parsing\/parserprinter\/print(_:)","role":"symbol","title":"print(_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"print"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Output"},{"kind":"text","text":") "},{"kind":"keyword","text":"rethrows"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Input"}],"type":"topic","kind":"symbol","abstract":[{"type":"text","text":"Attempts to print a well-structured piece of data to something more nebulous."}],"conformance":{"constraints":[{"code":"Input","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"_EmptyInitializable","type":"codeVoice"},{"type":"text","text":"."}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"type":"text","text":"Available when"}]}},"doc://co.pointfree.Parsing/documentation/Parsing/ParsePrint":{"url":"\/documentation\/parsing\/parseprint","title":"ParsePrint","role":"symbol","navigatorTitle":[{"text":"ParsePrint","kind":"identifier"}],"abstract":[{"text":"An entry to ","type":"text"},{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ParserBuilder","type":"reference","isActive":true},{"text":" syntax that requires the builder to be a printer.","type":"text"}],"kind":"symbol","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/ParsePrint","type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ParsePrint","kind":"identifier"}]},"doc://co.pointfree.Parsing/documentation/Parsing/Parser/map(_:)-4hsj5":{"type":"topic","url":"\/documentation\/parsing\/parser\/map(_:)-4hsj5","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"map"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"NewOutput"},{"kind":"text","text":">(("},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Output"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"NewOutput"},{"kind":"text","text":") -> "},{"preciseIdentifier":"s:7Parsing7ParsersO","kind":"typeIdentifier","text":"Parsers"},{"kind":"text","text":"."},{"preciseIdentifier":"s:7Parsing7ParsersO3MapV","kind":"typeIdentifier","text":"Map"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"NewOutput"},{"kind":"text","text":">"}],"title":"map(_:)","role":"symbol","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser\/map(_:)-4hsj5","kind":"symbol","abstract":[{"type":"text","text":"Returns a parser that transforms the output of this parser with a given closure."}]},"doc://co.pointfree.Parsing/documentation/Parsing/Conversion":{"navigatorTitle":[{"text":"Conversion","kind":"identifier"}],"type":"topic","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Conversion","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Conversion","abstract":[{"text":"Declares a type that can transform an ","type":"text"},{"type":"codeVoice","code":"Input"},{"text":" value into an ","type":"text"},{"type":"codeVoice","code":"Output"},{"text":" value ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"and","type":"text"}]},{"text":" transform an","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Output"},{"text":" value back into an ","type":"text"},{"type":"codeVoice","code":"Input"},{"text":" value.","type":"text"}],"url":"\/documentation\/parsing\/conversion","title":"Conversion","role":"symbol","kind":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/StringAbstractions":{"kind":"article","url":"\/documentation\/parsing\/stringabstractions","identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/StringAbstractions","role":"article","title":"String Abstractions","abstract":[{"type":"text","text":"Learn how to write parsers on different levels of string abstractions, giving you the ability to"},{"text":" ","type":"text"},{"text":"trade performance for correctness where needed.","type":"text"}],"type":"topic"},"doc://co.pointfree.Parsing/documentation/Parsing":{"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing","role":"collection","kind":"symbol","type":"topic","title":"Parsing","url":"\/documentation\/parsing","abstract":[{"type":"text","text":"A library for turning nebulous data into well-structured data, with a focus on composition,"},{"type":"text","text":" "},{"type":"text","text":"performance, generality, and ergonomics."}]},"https://github.com/pointfreeco/swift-parsing/blob/main/Sources/swift-parsing-benchmark/ReadmeExample.swift":{"type":"link","identifier":"https:\/\/github.com\/pointfreeco\/swift-parsing\/blob\/main\/Sources\/swift-parsing-benchmark\/ReadmeExample.swift","url":"https:\/\/github.com\/pointfreeco\/swift-parsing\/blob\/main\/Sources\/swift-parsing-benchmark\/ReadmeExample.swift","titleInlineContent":[{"type":"text","text":"benchmarks"}],"title":"benchmarks"},"doc://co.pointfree.Parsing/documentation/Parsing/Design":{"type":"topic","role":"article","kind":"article","abstract":[{"type":"text","text":"Learn how the library is designed, including its use of protocols, result builders and operators."}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Design","url":"\/documentation\/parsing\/design","title":"Design"},"doc://co.pointfree.Parsing/documentation/Parsing/Parser/map(_:)-18m9d":{"type":"topic","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"map","kind":"identifier"},{"text":"<","kind":"text"},{"text":"C","kind":"genericParameter"},{"text":">(","kind":"text"},{"text":"C","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"Parsers","preciseIdentifier":"s:7Parsing7ParsersO","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"MapConversion","preciseIdentifier":"s:7Parsing7ParsersO13MapConversionV","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"C","kind":"typeIdentifier"},{"text":">","kind":"text"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser\/map(_:)-18m9d","abstract":[{"text":"Returns a parser-printer that transforms the output of this parser with a given conversion.","type":"text"}],"url":"\/documentation\/parsing\/parser\/map(_:)-18m9d","title":"map(_:)","role":"symbol","kind":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/Parse":{"kind":"symbol","title":"Parse","abstract":[{"type":"text","text":"A parser that attempts to run a number of parsers to accumulate their outputs."}],"navigatorTitle":[{"text":"Parse","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parse","type":"topic","url":"\/documentation\/parsing\/parse","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Parse","kind":"identifier"}],"role":"symbol"},"doc://co.pointfree.Parsing/documentation/Parsing/Parser":{"kind":"symbol","title":"Parser","abstract":[{"type":"text","text":"Declares a type that can incrementally parse an "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" value from an "},{"type":"codeVoice","code":"Input"},{"type":"text","text":" value."}],"navigatorTitle":[{"text":"Parser","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.Parsing\/documentation\/Parsing\/Parser","type":"topic","url":"\/documentation\/parsing\/parser","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Parser","kind":"identifier"}],"role":"symbol"}}}